题目描述：
给定一个正整数n，请按非递增顺序输出所有将 n 拆分成若干个正整数之和的方案。每个方案中的数字必须满足非递增顺序（即 a1≥a2≥⋯≥ak>0)，不同方案之间按分拆序列的字典逆序排列（即优先输出首项较大的方案，首项相同时优先输出次项较大的方案，依此类推）。

输入格式：
一个正整数 n（1≤n≤20）。

输出格式：
每行输出一个分拆方案，格式为 n=a1+a2+...+ak，其中a1≥a2≥⋯≥ak>0。方案必须按字典逆序排列（见样例）。

样例：
输入数据 1：
4

输出数据 1：
4=4
4=3+1
4=2+2
4=2+1+1
4=1+1+1+1

代码：
#include <bits/stdc++.h>
using namespace std;
// n 表示要拆分的整数，a[] 用于存储当前拆分出来的每一项
int n,a[21];
// fun(x,k) 表示把数字x拆分成若干个正整数之和（拆到了第k个位置）
// 参数说明：
//   x：当前还需要拆分的数
//   k：当前拆到第几个位置（a[k]表示第k个拆分项）
void fun(int x,int k){
    // 递归出口：如果x已经拆分到0，说明当前方案有效
    if(x==0){
        cout<<n<<'='<<a[1]; // 输出等式左侧和第一个拆分项
        for(int i=2;i<k;i++)
            cout<<'+'<<a[i];  // 输出后续的拆分项，每项前加加号
        cout<<endl;             // 输出一个换行，代表一个完整拆分方案
        return;                   // 返回递归上一层
    }
    // 枚举所有可以选择放在第k个位置上的数（从大到小）
    for(int i=x;i>=1;i--){
        // 拆第一个数，或者当前拆分数不大于前一个（保证不递增，防止重复）
        if (k==1 || i<=a[k-1]){
            a[k]=i;           // 把i放在第k个位置
            fun(x-i,k+1);// 继续拆分剩下的x-i，递归到下一个位置
            // 递归返回后无需回溯清空a[k]，因为下次循环会覆盖
        }
    }
}
int main() {
    cin>>n;      // 输入要拆分的正整数
    fun(n,1);     // 从第1个位置开始拆分
    return 0;
}
