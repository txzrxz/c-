寻宝：

题目描述：
侠盗 Hank 经过千难万险终于来到了恶人岛，为了拿到恶人岛的宝座去帮助穷人，Hank 先对恶人岛进行了侦查，发现恶人岛有一个迷阵，宝藏摆在了迷阵的深处。迷阵由 M×N 个方 格组成，有的方格内有可以发现 Hank 的守卫，而有的方格内则是安全。每个方格可以向上下左右四个方向走。为了展现自己的实 力，Hank 决定不仅要拿走恶人岛的宝藏，还要给他们留一封信，告诉恶人自己有 g 种方法 找到宝藏。现在要求你来帮助他实现这个目标。 迷阵越大，守卫越多。

输入格式：
输入有一组测试数据，以两个非零整数 N 和 M 开始，两者均不大于20。N表示迷阵行数, M表示迷阵列数。接下来有 N 行, 每行包含 M 个字符,不同字符分别代表不同含义: ‘@’：Hank 所在的位置； ‘.’：可以安全通行的方格； ‘#’：有守卫的方格； ‘*’：宝藏所在位置。

输出格式：
一个整数 g,表示 Hank 有 g 种方法可以找到宝藏。如果他不可能找到宝藏, 则输出-1。

样例：
输入数据 1：
8 8
.@##...#
#....#.#
#.#.##..
..#.###.
#.#...#.
..###.#.
...#.*..
.#...###

输出数据 1：
4

代码：
#include <bits/stdc++.h>
using namespace std;
//能走就走过去，不能走就回到上一个位置尝试其他方向：深度优先搜索 
int n,bx,by,m,cnt,v[21][21];//v:标记 
char a[21][21];
int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}};//方向数组，给出上下左右每个方向x和y的变化 
void dfs(int x,int y){//(x,y)为当前所在的位置 
	if(a[x][y]=='*'){//是不是终点 
		cnt++;//标记已经走到终点 
		return; 
	}
	for(int i=0;i<4;i++){
		int tx=x+dis[i][0],ty=y+dis[i][1];
		if(tx>=1 && tx<=m && ty>=1 && ty<=n && a[tx][ty]!='#' && v[tx][ty]==0){
			v[tx][ty]=1; 
			dfs(tx,ty);
			v[tx][ty]=0;//要统计不同条路径的条数
			//所以当x,y尝试其他方向之前，需要把刚才标记的(tx,ty)取消标记 
		}
	}
}
int main() {
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			if(a[i][j]=='@'){//记录下起点
				bx=i;
				by=j; 
			}
		}
	}
	v[bx][by]=1;
	dfs(bx,by);
	if(cnt==0)cout<<-1;
	else cout<<cnt;
	return 0;
}
