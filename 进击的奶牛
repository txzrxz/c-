进击的奶牛：

题目描述：
农夫约翰建造了一座有 n 间牛舍的小屋，牛舍排在一条直线上，第 i 间牛舍在 x[i] 的位置，但是约翰的 m 头牛对小屋很不满意，因此经常互相攻击。约翰为了防止牛之间互相伤害，

因此决定把每头牛都放在离其它牛尽可能远的牛舍。也就是要最大化最近的两头牛之间的距离。

牛们并不喜欢这种布局，而且几头牛放在一个隔间里，它们就要发生争斗。为了不让牛互相伤害。约翰决定自己给牛分配隔间，使任意两头牛之间的最小距离尽可能的大，那么，这个最大的最小距离是多少呢？

输入格式：
第一行用空格分隔的两个整数 n 和 m；下面 n 行为 n 个用空格隔开的整数，表示位置 x[i]​ 。

输出格式:
一行一个整数，表示最大的最小距离值。

输入输出样例 #1
输入 #1:
5 3
1
2
8
4
9

输出 #1:
3

说明/提示:

【样例解析】
把牛放在 1，4，8 这三个位置，距离是 3。容易证明最小距离已经最大。

【数据范围】
对于 100%100% 的数据，2≤n≤10^5,0≤x[i]≤10^9,2≤m≤n。不保证 x 数组单调递增。

代码：
#include <bits/stdc++.h>
using namespace std;
/*
n间牛舍 m头牛 一头牛一间牛舍，保证任意相邻两头牛之间的最小距离最大
任意两头牛之间的距离，都 >= x ，且 x 为满足上面条件的最大值
只需要找到一个最大的 x 能够满足 1头牛1间牛舍 
二分 x 的范围，如果针对当前二分的 x ，能放 m 头牛，说明 x 可能是结果，也可能有更大的
不能，x 太大了 
*/
int n,m,a[100001];
bool check(int x){
	//第1间牛舍必须得用 
	int cnt=1,last=a[0];
	for(int i=0;i<n;i++){
		if(a[i]-last>=x){
			cnt++;
			last=a[i];
		}
	}
	return cnt>=m;
}
int main() {
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>a[i];
	sort(a,a+n);//给牛舍的位置进行从小到大的排序
	int l=1,r=1e9,ans=1;//l = 最小的值 r = 最大的差值 (a[n-1]-a[0])
	while(l<=r){
		int mid=(l+r)/2;
		if(check(mid)){//最小距离为 mid 时，能不能安排 m 头牛 
			ans=mid;
			l=mid+1; 
		}else{
			r=mid-1;
		}
	}
	cout<<ans;
	return 0;
}
