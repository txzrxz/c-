描述：

扫雷游戏是一款十分经典的单机小游戏。在 n行 m 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。
现在给出n行m列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。
注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。

输入描述：

输入文件第一行是用一个空格隔开的两个整数n和m，分别表示雷区的行数和列数。
接下来 n行，每行m 个字符，描述了雷区中的地雷分布情况。字符’*’表示相应格子是地雷格，字符’?’表示相应格子是非地雷格。相邻字符之间无分隔符。

输出描述：

输出文件包含 n 行，每行 m 个字符，描述整个雷区。用’*’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

用例输入 1 

3 3
*??
???
?*?
用例输出 1 

*10
221
1*1
用例输入 2 

2 3
?*?
*??
用例输出 2 

2*1
*21
提示：

对于 100%的数据，1≤n≤100,1≤m≤100。

来源：

noip复赛 二维数组



## 💡 解题思路

这道题的核心思想是：
1. 读入雷区的地雷分布
2. 对于每个非地雷格，统计其周围8个方向的地雷数量
3. 输出结果，地雷格用'*'表示，非地雷格用周围地雷数表示

**关键点**：要注意边界检查，避免数组越界！

## 📝 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n, m; // n:行数, m:列数
    cin >> n >> m;
    char a[n][m];
    
    // 读入雷区数据
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            cin >> a[i][j];
        }
    }
    
    // 处理每个格子
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(a[i][j] == '*') {
                // 如果是地雷格，直接输出*
                cout << '*';
            } else {
                // 如果是非地雷格，统计周围地雷数
                int sum = 0;
                
                // 检查周围8个方向（注意边界检查）
                for(int di = -1; di <= 1; di++) {
                    for(int dj = -1; dj <= 1; dj++) {
                        if(di == 0 && dj == 0) continue; // 跳过自己
                        
                        int ni = i + di; // 新的行坐标
                        int nj = j + dj; // 新的列坐标
                        
                        // 边界检查
                        if(ni >= 0 && ni < n && nj >= 0 && nj < m) {
                            if(a[ni][nj] == '*') {
                                sum++;
                            }
                        }
                    }
                }
                cout << sum;
            }
        }
        cout << endl;
    }
    return 0;
}
```

## 🔍 代码解析

### 主要步骤：
1. **输入处理**：读入雷区的行数、列数和地雷分布
2. **遍历处理**：对每个格子进行处理
3. **地雷格**：直接输出 '*'
4. **非地雷格**：统计周围8个方向的地雷数量

### 关键技巧：
- **双重循环遍历8个方向**：使用 `di` 和 `dj` 从 -1 到 1 的组合
- **边界检查**：确保 `ni` 和 `nj` 在有效范围内
- **跳过自己**：当 `di == 0 && dj == 0` 时跳过

### 时间复杂度：
- O(n × m × 8) = O(n × m)，对每个格子检查周围8个方向

这种写法比原来的代码更简洁、更不容易出错！✨
