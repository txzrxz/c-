可可岛的宝藏：

题目描述：
可可岛位于距哥斯达黎加海岸300英里的海中，曾是17世纪海盗的休息站，海盗们将掠夺的财宝在此装装卸卸，埋埋藏藏，为这个无名小岛平添了神秘色彩，据说岛上至少埋有6处宝藏。某天童童历经千难万险到了可可岛上，上面有许多珍贵的金属，童童虽然更喜欢各种宝石的艺术品，可是也不拒绝这样珍贵的金属。但是他只带着一个口袋，口袋至多只能装重量为w的物品。岛上金属有 s 个种类, 每种金属重量不同，分别为 n1,n2,…,ns，同时每个种类的金属总的价值也不同，分别为 v1,v2, …, vs。童童想一次带走价值尽可能多的金属，问他最多能带走价值多少的金属。注意到金属是可以被任意分割的，并且金属的价值和其重量成正比。

输入格式：
第1行是测试数据的组数 k，后面跟着 k 组输入。 每组测试数据占3行，第 1 行是一个正整数 w(1≤w≤10000)，表示口袋承重上限。 第 2 行是一个正整数 s(1≤s≤100) ，表示金属种类。 第 3 行有 2s 个正整数，分别为n1,v1,n2,v2,…,ns,vs分别为第一种，第二种，…，第 s 种金属的总重量和总价值 (1≤ni≤10000,1≤vi≤10000)。

输出格式：
k 行，每行输出对应一个输入。输出应精确到小数点后 2 位。

样例：
输入数据 1：
2
50
4
10 100 50 30 7 34 87 100
10000
5
1 43 43 323 35 45 43 54 87 43

输出数据 1：
171.93
508.00

代码：
#include <bits/stdc++.h>
using namespace std;
struct node{
	int n,v;//金属，重量和价值
	double p;//单位价值 
}a[101]; 
bool cmp(node a,node b){
	return a.p>b.p;
}
int k,s,w;
int main() {
	cin>>k;
	while(k--){
		double ans=0;
		cin>>w>>s;//w:背包容量 s(1~100):物品数量
		for(int i=0;i<s;i++){
			cin>>a[i].n>>a[i].v;
			a[i].p=a[i].v*1.0/a[i].n;
		}
		sort(a,a+s,cmp);
		for(int i=0;i<s;i++){
			if(w>=a[i].n){//能装下 
				w-=a[i].n;//占用空间 
				ans+=a[i].v;//产生价值 
			}else{//装不下，只能装w单位的a[i]物品 
				ans+=a[i].p*w;
				break;
			}
		}
		printf("%.2lf\n",ans);
	}
	return 0;
}
