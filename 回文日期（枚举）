回文日期：

题目描述：
在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。现在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存在的日期是回文的。

一个 8 位数字是回文的，当且仅当对于所有的 i（1≤i≤8）从左向右数的第 i 个数字和第 9−i 个数字（即从右向左数的第 i 个数字）是相同的。

例如：

对于 2016 年 11 月 19 日，用 8 位数字 20161119 表示，它不是回文的。 对于 2010 年 1 月 2 日，用 8 位数字 20100102 表示，它是回文的。 对于 2010 年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。

每一年中都有 12 个月份：

其中，1,3,5,7,8,10,12 月每个月有 31 天；4,6,9,11 月每个月有 30 天；而对于 2 月，闰年时有 29 天，平年时有 28 天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

这个年份是 4 的整数倍，但不是 100 的整数倍； 这个年份是 400 的整数倍。 例如：

以下几个年份都是闰年：2000,2012,2016。 以下几个年份是平年：1900,2011,2014。

输入格式：
两行，每行包括一个 8 位数字。

第一行表示牛牛指定的起始日期。

第二行表示牛牛指定的终止日期。

保证 date1和 date2都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。保证 date1一定不晚于 date2。

输出格式：
一个整数，表示在 date1和 date2之间，有多少个日期是回文的。

样例：
输入数据 1：
20110101
20111231

输出数据 1：
1

代码：
#include <bits/stdc++.h>
using namespace std;
int y[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
/*
步骤:
1、去掉不真实存在的日期
2、判断平年闰年
3、判断大小月
4、判断回文数
每一年的回文日期只有1个，例：2011 -> 1102 : 20111002
*/
int main() {
	int d1,d2,sum=0;
    cin>>d1>>d2;//判断d1~d2之间的回文日期的数量
    for(int i=1;i<=12;i++){//枚举月份 AB
        for(int j=1;j<=y[i];j++){//第i月天数 CD
            int md=i*100+j;//ABCD 后四位
            int y2=j%10*1000 + j/10*100 + i%10*10 + i/10;//逆序排列，前四位
            //     D*1000      C*100      B*10      A
            int ymd=y2*10000+md;//ymd必定是合法的日期
            //可能年份是3位的，但是3位的年份肯定不在d1~d2的范围内
            if(ymd>=d1 && ymd<=d2){
                sum++;
            }
        }
    }cout<<sum;
    return 0;
}
