迷宫：

题目描述：
有 1 个 n×n 的迷宫方格，在方格内“0”表示可以通行，“1”表示是障碍物不能通行，在（n，n）位置有一个宝箱。现在有个人在左上角（ 1 , 1 ）的位置，他在迷宫内可以向当前位置的上、下、左、右四个方向行走，能不能在迷宫里走到宝箱位置（ n，n ）。注意：测试数据保证起点和终点均为“0”，走的过程不能走出迷宫。

输入格式：
输入第一行为 n（2 ≤n≤10 ），表示 n×n 的方格，接下来有 n 行，每行 n 个整数， 0 表示可以行走，1 表示不能行走，每个整数之间有个空格。

输出格式：
如果可以走到终点，输出“YES”，否则输出“NO”

样例：
输入数据 1：
3
0 0 1
1 0 0
0 1 0

输出数据 1：
YES

代码：
#include <bits/stdc++.h>
using namespace std;
int n,a[11][11],flag;//能走就走过去，不能走就回到上一个位置尝试其他方向：深度优先搜索 
int dis[4][2]={{-1,0},{1,0},{0,-1},{0,1}};//方向数组，给出上下左右每个方向x和y的变化 
void dfs(int x,int y){//(x,y)为当前所在的位置 
	if(x==n && y==n){//是不是终点 
		flag=1;//标记已经走到终点 
		return; 
	}
	//依次访问(x,y)的四个方向 :上下左右 
	for(int i=0;i<4;i++){//找到能走的方向，能走就直接走
		//求出该方向要去的点(tx,ty) 上(x-1,y) 下(x+1,y) 左(x,y-1) 右(x,y+1)
		int tx=x+dis[i][0],ty=y+dis[i][1];
		//(tx,ty)没有越界 && a[tx][ty]!=1 && 不是当前路径上已走过的点(标记)
		if(tx>=1 && tx<=n && ty>=1 && ty<=n && a[tx][ty]!=1){
			a[tx][ty]=1;//把(tx,ty)标记一下 
			dfs(tx,ty);//走到(tx,ty)接着从(tx,ty)继续走 
		}
	}
} 
int main() {
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	a[1][1]=1;//直接在地图上把走过的点标记(改成1)
	dfs(1,1);
	if(flag==1)cout<<"YES";
	else cout<<"NO";
	return 0;
}
