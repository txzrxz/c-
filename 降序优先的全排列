降序优先的全排列:

题目描述：
给定n个互不相同的正整数，这些数可能是乱序的。请编写一个程序，输出这些数字的所有可能全排列，但要求先输出较大的数字。

输入格式：
第一行包含一个正整数n（1 ≤ n ≤ 9）。 第二行包含n个互不相同的正整数，用空格分隔。

输出格式：
输出所有可能的全排列，每种排列占一行。

样例：
输入数据 1:
3
9 7 12

输出数据 1:
12 9 7
12 7 9
9 12 7
9 7 12
7 12 9
7 9 12

代码：
#include <bits/stdc++.h>
using namespace std;
/*
a[]:存储输入并排序后的原始数据(下标0~n-1)
v[]:标记数组，记录对应索引的数字是否已被使用
res[]:存储当前排列结果(下标1~n)
n:表示要排列的数字总个数
*/
int a[11],v[11],n,res[11];
// 递归函数：在第x个位置放置一个未使用过的数
void fun(int x){
    // 若x已等于n+1，说明前n个位置已排满，生成完整排列
    if(x==n+1){
        for(int i=1;i<=n;i++)cout<<res[i]<<' ';// 输出结果 
        cout<<endl;//输出一个换行
        return;//输出完结果直接返回
    }
    // 枚举所有可能放在第x个位置的数(使用a数组中0~n-1的排序后数据)
    for(int i=0;i<n;i++){
        if(v[i]==0){// 若a[i]未被使用，能放 
            v[i]=1;// 标记a[i]已被使用
            res[x]=a[i];// 将排序后的数字a[i]放入结果位置x
            fun(x+1);// 处理下一个位置
            v[i]=0;// 回溯
        }
    }
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    sort(a,a+n,greater<int>());
    fun(1);
    return 0;
}
